# C++ TODO

- [ ] virtual inherit
- [ ] copy constructor

# C++ Hello World

``` c++
#include <iostream>
// using namespace std;
int main()
{
    printf("Hello, World!\n");
    std::cout << "hello std::" << std::endl;
    return 0;
}
```

> - endl和'\n'差不多，但是endl会flush
>
> - <>先去系统目录中找头文件，如果没有在到当前目录下找。所以像标准的头文件 stdio.h、stdlib.h 等用这个方法。
>
> - **" "** 首先在当前目录下寻找，如果找不到，再到系统目录中寻找。 这个用于 include 自定义的头文件，让系统优先使用当前目录中定义的。
>
> - 真正的开发过程中， 尽量避免使用 **using namespace std;** 等直接引入整个命名空间，否则会因为命名空间污染导致很多不必要的问题， 比如自己写的某个函数，名称正好和 **std** 中的一样， 编译器会不知道使用哪一个， 引起编译报错， 建议使用: `std::cout`
>
> - **.C++** 文件和 **.h** 文件的区别：
>
>   C++文件用于存放类的定义 definition，h 文件用于存放类的声明 declaration。
>
>   在头文件中声明了一个函数或者类，需要定义或者使用这个函数或者类时，需要在 C++ 文件中 include 这个头文件

# L-value, R-value

> [从汇编代码上看，左值引用和右值引用本质都是指向值的地址，那为什么c++里要对2者做出区分?](https://www.zhihu.com/question/360636808/answer/2353439219)
>
> [理解 C/C++ 中的左值和右值](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)

C遵循传统的CPL划分方式：左值被定义为标识一个对象的表达式，其他的都是右值（函数和非对象值）。

C++11开始，有了更加细分的分类：

![](https://pic1.zhimg.com/v2-60953ef4f577788e2f96dbcbb960d3a4_r.jpg)

## L-value

左值是表达式（不一定是赋值表达式）后依然存在的持久对象；可以将左值看作是一个关联了名称的内存位置，允许程序的其他部分来访问它。

左值具有以下特征：

- 可通过取地址运算符获取其地址
- 可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数
- 可以用来初始化左值引用(后面有讲)

那么哪些都是左值呢?查了相关资料，做了些汇总，基本覆盖了所有的类型：

- 变量名、函数名以及数据成员名
- 返回左值引用的函数调用
- 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
- 解引用表达式`*ptr`
- 前置自增和自减表达式(++a, ++b)
- 成员访问（点）运算符的结果
- 由指针访问成员（ -> ）运算符的结果
- 下标运算符的结果([])
- 字符串字面值(`"abc"`)

## Pure Right Value

字面值或者函数返回的非引用都是纯右值。

以下表达式的值都是纯右值：

- 字面值(字符串字面值除外)，例如1，'a', true等
- 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
- 后置自增和自减表达式(a++, a--)
- 算术表达式
- 逻辑表达式
- 比较表达式
- 取地址表达式
- lambda表达式

纯右值特征：

- 等同于C++11之前的右值
- 不会是多态
- 不会是抽象类型或数组
- 不会是不完全类型

## eXpiring Value

将亡值，顾名思义即将消亡的值，是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。

**可以通过右值引用延长生命周期，比如避免在函数返回时销毁。**

xvalue 只能通过两种方式来获得，这两种方式都涉及到将一个左值赋给(转化为)一个右值引用：

- 返回右值引用的函数的调用表达式,如 static_cast<T&&>(t); 该表达式得到一个 xvalue
- 转换为右值引用的转换函数的调用表达式，如：std::move(t)、satic_cast<T&&>(t)

在C++11之前，s = fun();会调用拷贝构造函数，会将整个str复制一份，然后把str销毁。如果str特别大的话，会造成大量额外开销。在这一行中，s是左值，fun()是右值(纯右值)，fun()产生的那个返回值作为一个临时值，一旦str被s复制后，将被销毁，无法获取、也不能修改。

**自C++11开始，引入了move语义，编译器会将这部分优化成move操作**，即不再是之前的复制操作，而是move。此时，str会被进行隐式右值转换，等价于static_cast<std::string&&>(str)，进而此处的 s 会将 foo 局部返回的值进行移动。

>  无论是C++11之前的拷贝，还是C++11的move，str在填充(拷贝或者move)给s之后，将被销毁，而被销毁的这个值，就成为将亡值。  

将[亡值](https://www.zhihu.com/search?q=亡值&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"2353439219"})就定义了这样一种行为：具名的临时值、同时又能够被move。











# C++ 数据类型, typedef, enum

> `sizeof(type), numeric_limits<type>::max/min`可获取下面的值

| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |

---

可以自定义类型的别名，如`typedef int zsa; zsa a = 1;`

> 关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能，有自己的作用域。
>
> \#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查。没有自己的作用域





# C++ 常量

字符串分行：

``` c++
string a = "htrg \
           awd";
```

> C++的字符串：std::string
>
> C的字符串：char *a = "e2131e"

C-Style String: `char str = "S"`，实际上试图让`str`成为`“S\0”`这个字符串的指针，而这将导致编译器不通过。



# C++ 存储

类

> - auto
> - extern
> - static
> - register
> - mutable
> - thread_local

![](https://pic4.zhimg.com/v2-7d832435a944a6036212902cdb99bdcb_r.jpg)

## Extern 全局变量

**extern** 存储类用于提供一个全局变量的引用，全局变量对全工程都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候。



## Static 静态变量

> [C/C++ 中 static 的用法全局变量与局部变量](https://www.runoob.com/w3cnote/cpp-static-usage.html)

### Static Intro

我们知道在函数内部定义的变量，当程序执行到它的定义处时，编译器为它在栈上分配空间；

函数在栈上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 

最容易想到的方法是定义为全局的变量，**但定义一个全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围**（使得在此函数中定义的变量，不仅仅只受此函数控制）。static 关键字则可以很好的解决这个问题。

另外，在 C++ 中，需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见时，可将其定义为静态数据。

### 静态数据的存储，全局（静态）存储区

**全局（静态）存储区**：

- 分为 DATA 段和 BSS 段。DATA 段（全局初始化区）存放初始化的全局变量和静态变量;
- BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。
- 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。

在 C++ 中 static 的内部实现机制：静态数据成员要在程序一开始运行时就必须存在。因为函数在程序运行中被调用，所以**静态数据成员不能在任何函数内分配空间和初始化。**

这样，它的空间分配有三个可能的地方:

1. 作为类的外部接口的头文件，那里有类声明；
2. 类定义的内部实现，那里有类的成员函数定义；
3. 应用程序的 main() 函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。

static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

**优势：**可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。



### Static 变量和普通变量

**静态全局变量有以下特点：**

1. 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
2. 未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
3. 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
4. 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

**优点：**静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

**全局变量和全局静态变量的区别**

1. 全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
2. 全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

### Static 用法

static 关键字最基本的用法是：

- 1、被 static 修饰的变量属于类变量，可以通过**类名.变量名**直接引用，而不需要 new 出一个类来
- 2、被 static 修饰的方法属于类方法，可以通过**类名.方法名**直接引用，而不需要 new 出一个类来

被 static 修饰的变量、被 static 修饰的方法统一属于类的静态资源，是类实例之间共享的，换言之，一处变、处处变。

在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。

静态成员的定义或声明要加个关键 static。静态成员可以通过双冒号来使用即 **<类名>::<静态成员名>**。

















# C++ 函数，lambda

## Call Method

- 传值；
- 指针调用：传入地址给形参；`void func(int *a, int *b)`
- **引用调用**：`void func(int &a, int &b)`

``` c++
# include <stdio.h>

void swapVal(int a, int b) {
    int tmp = a;
    a = b;
    b = a;
    return;
}

void swapPnt(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
    return;
}

void swapRef(int &a, int &b) {
    int tmp = a;
    a = b;
    b = tmp;
    return;
}

int main() {
    int x = 114; 
    int y = 514;

    swapVal(x, y);
    printf("x = %d, y = %d\n", x, y);

    swapPnt(&x, &y);
    printf("x = %d, y = %d\n", x, y);

    swapRef(x, y);
    printf("x = %d, y = %d\n", x, y);
    return 0;
}
```

## LAMBDA

创建一个函数对象。

示例：`auto funcName = [](intsa, int b){return a+b;};`

完整表达式的组成：

``` c++
[ capture-list ] ( params ) mutable(optional) exception(optional) attribute(optional) -> return(optional) { body } 
```

- params：和普通函数一样；
- mutable：**默认按值捕获的类型是 const 的， 要修改需要加这个关键字**
- exception
- attribute
- return：可省略，会自动推导
- body：具体逻辑
- 捕获列表：在Lambda表达式内可以访问当前作用域的变量
  - `[]`什么都不捕获
  - `[a]`传值
  - `[&b]`引用
  - `[&]`按值捕获可见范围内的所有局部变量（不建议）
  - `[=]`按引用捕获可见范围内的所有局部变量（不建议）
- 在成员函数中的 Lambda 表达式可以捕获当前对象的 this 指针，让 Lambda 表达式拥有和当前类成员同样的访问权限，可以修改类的成员变量，使用类的成员函数：this 指针只能按值捕获 `[this]` ，不能按引用捕获 `[&this]` 。





# C++数字，随机数，数学运算

## 数学计算

> `#include <cmath>`

| 序号 | 函数 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |
| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |
| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |
| 4    | **double log(double);** 该函数返回参数的自然对数。           |
| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |
| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |
| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |
| 9    | **double fabs(double);** 该函数返回任意一个浮点数的绝对值。  |
| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |

## 随机数

设置种子：`#incliude <ctime>; srand((unsigned)time(NULL))；`

- time() 不需要传入参数，返回时间戳
- (unsigned)，将`time_t`转化为`unsigned`

生成随机数：`rand()`返回0~32767（随系统变化）的数字



# C++ 数组

声明：`type NAME[size];`

定义：`int lst[] = {1, 1, 4, 5, 1, 4};`自动生成长度为6的数组，当然也可以手动定义`lst[6]`

## 二维数组

声明`int lst[4][3];`定义一个4*3的二维数组

初始化可以有两种：

``` c++
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};

int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

![](https://www.runoob.com/wp-content/uploads/2014/09/two_dimensional_arrays.jpg)

## 数组指针

数组标识符可以直接当指针使用。

``` c++
#include <stdio.h>

int main() {
    int lst[6] = {1, 1, 4, 5, 1, 4};
    //int *p = lst;
    printf("%d\n", *(lst+3));  // lst[3] == 5
    return 0;
}
```

如果是二维数组：

``` c++
int main() {
    int lst[3][2] = {1, 1, 4, 5, 1, 4};
    //int *p = lst;
    printf("%d\n", *(lst[0]+1)); // 
    return 0;
}
```

`lst+1`是`lst[1]`的指针

可以改lst对应的值，但是不能更改lst这个指针指向的地址。

## 传递数组至函数

> 就函数而言，数组的长度是无关紧要的，因为 C++ 不会对形式参数执行边界检查。

1. `retType name(elementType *arg);`
2. `retType name(elementType arg[size]);`
3. `retType name(elementType arg[]);`

以上三种方法都一样，因为编译器都会把形参作为一个指针。



## 从函数返回数组

只能返回一个指针：`int * func(){return pnt;};`

**C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量，因为return后释放栈上空间了。**

# C++ 字符串

> `\0`为终止符，NULL

`char name[7] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', '\0'};`

`char name[] = "abcdefg";`，此处编译器将自动判断长度

以上两种都很C。

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = "runoob"; string str2 = "google"; string str = str1 + str2;` |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

---

C++提供了`string`类：`string a = "eewfrg";`

string类提供了一系列针对字符串的操作，比如：

1. append() -- 在字符串的末尾添加字符

2. find() -- 在字符串中查找字符串
3.  insert() -- 插入字符
4. length() -- 返回字符串的长度
5. replace() -- 替换字符串
6. substr() -- 返回某个子字符串

# C++ 引用

> 变量的别名
>
> 类似指针，但是是隐式的

## 声明

- 必须声明时定义；
- 不存在NULL引用，必须指向一个合法的地址。
- 作用和`int const *p = a`差不多



## 把引用作为参数

就和python里的引用一样，只不过在c++所有都是mutable的。

比如定义一个交换函数，只要我在函数声明里写了引用类型，就可以正常交换（不用考虑什么取地址取内容）。

## 把引用作为返回值

和返回指针一样，返回时要看作用域。

1. 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
2. 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
3. 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

## const Reference, R-value Reference

经典的引用：

`int a = 1; int &b = a;`

但这样只能引用左值，假如我想引用一个右值，比如一个字面量呢？

`const int &a = "dwa";`常引用，`c-ref`，`const ref`

`int &&a = "dwa";`右值引用

# C/C++ DATE, TIME

`#include <ctime>`

有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

``` c++
struct tm {
  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
  int tm_min;   // 分，范围从 0 到 59
  int tm_hour;  // 小时，范围从 0 到 23
  int tm_mday;  // 一月中的第几天，范围从 1 到 31
  int tm_mon;   // 月，范围从 0 到 11
  int tm_year;  // 自 1900 年起的年数
  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
  int tm_isdst; // 夏令时
};
```

# C++ IO

| 头文件     | 函数和描述                                                   |
| :--------- | :----------------------------------------------------------- |
| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |
| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节 |

``` C++
cin >> var;
cout << var << endl;
// cerr 非缓冲！
// clog 缓冲！
```

# C++ Class, Obj

![](https://www.runoob.com/wp-content/uploads/2013/12/oopxxx.png)

## 访问，声明

访问成员变量或函数：`.`

**一般是在类内声明方法，但是在类外定义方法**。此时需要使用`::`(**范围解析运算符**)，如：

`void className::methodName(void) {};`

否则就会定义一个全局函数。对全局函数来说，直接用标识符和`::[identifier]`是一样的。

变量的话直接用`.`就行。

类内可以直接相互访问，不用非得`this->`

> 各种成员函数吗，不管是公有私有，还是普通成员或构造析构，都可以类内声明，类外定义：
>
> 原则是将**实现细节从接口设计中分离出来**。如果以后找到了更好的、实现数据表示或成员函数细节的方法，可以**对这些细节进行修改，而无需修改程序接口**这使程序维护起来更容易

## 成员函数

如果在类内部定义了，那就默认是`inline`的，即使没加标识符。如果`inline`的话，最好是在头文件里直接写出来。

**不管什么访问权限，都可以在类外定义。**

类方法只有一个内存，所有对象共享一个类方法。

## 访问修饰符，继承

### public

**公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值

### private(DEFAULT  TYPE)

**私有**成员**变量或函数**在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数。

### protected

**protected（受保护）**成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员**在派生类（即子类）中是可访问的**。

### Inheritance Feature

> 见 C++ 继承

## 构造函数，析构函数，拷贝构造

### Constructor

> 和`__init__.py`一样

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行(当然也可用于重新赋值)。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

> 构造函数可以写成private，此时将出现[单例模式](https://blog.csdn.net/weixin_43778179/article/details/105073150)：
>
> 如果构造函数和拷贝构造函数都是private，则将只会出现一个该类的实例

``` C++
class Name {
    public:
    	Name() {}; // this is constructor
};
```

利用这点可以初始化：

```c++
class Name {
    public:
    	int score;
    	int age;
    	int salary;
    	Name(int, int, int);
}
Name::Name(int a, int b, int c) {
    score = a;
    age = b;
    salary = c;
}

int main() {
  Name inst = Name(100, 18, 10000);  
};
```

**ATTENTION! 构造函数的参数不能和成员变量重名!**两种解决方案：

1. 类声明中变量加上`m_`前缀表示是member；
2. 类声明中变量加上`_`后缀；



但是这样定义构造函数可能有点麻烦，所以**可以用初始化列表**：

``` c++
Name::Name(int a, int b, int c): score(a), age(b), salary(c) {};
```

在调用构造函数时有两种方式：

1. `Student inst = Student(...)`
2. `Student inst(...)`更紧凑

---

通常还需要给构造函数加上默认值，比如我不想直接在生成对象时输入所有的值：

1. 在定义构造函数时，参数可加上默认值；
2. 因为函数签名是由函数名、形参组成的嘛！所以可以定义一个正常的构造函数（不带默认值），再定义一个无形参但是定义里默认赋值的构造函数，如下所示：

```c++
/*

class Student 
{
    public:
        Student(std::string, int, int);
        Student();
};

*/

Student::Student(std::string str, int math, int eng)
{
    score_eng = eng;
    score_math = math;
    name = str;
}

Student::Student()
{
    score_eng = 0;
    score_math = 0;
    name = "NULL";
}

int main()
{
    Student colin("Colin McRae", 97, 66);
    Student mary;
    colin = Student("CoLin McRae", 66, 97);  //会创建一个临时对象
    return 0;
}
```



### Destructor

构造函数可以有多个，但是析构函数只能有一个，**而且不能带参数**：用于删除对象时/跳出程序时前释放资源。

``` c++
class Name {
    public:
    	~Name(){...;}; // destroyer
}
```

普通场景下，构造函数和析构函数都是public，但也有特殊情况：[Constructor/Destructor 设置成protected / private的原因](https://blog.csdn.net/fly542/article/details/8055207)



### Copy Constructor

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。**如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。**拷贝构造函数的最常见形式如下：

``` c++
className(const className *obj){ // obj: a object being copied
    // something
}
```





# C++ 继承

``` C++
// 继承的写法
class A{};
class B{};
class C{};

class Z: public A, private B, protected C{};
```

有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

- 1.**public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
- 2.**protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
- 3.**private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，上面两点都没有改变：

- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- 2.protected 成员可以被派生类访问。

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |
